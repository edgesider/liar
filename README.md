# Liar

- 支持连接后脱离

## 编译运行

```bash
make
./liar <prog> [arg] ...
```

## 思路

1. 建立文件描述符发送通道

父进程在fork之前，通过socketpair(AF_UNIX)建立一个unix域套接字，之后通过该套接字进行父子进程间的文件描述符传送。

2. 创建共享文件描述符

使用ptrace来hook子进程的socket调用。
   a. 在wait()到enter-stop时，由父进程创建一个socket（记为fdp），并使用sendmsg发送给子进程；
   b. 接着使用PTRACE_SETREGS把子进程的socket调用替换为recvmsg（一是为了避免只发送不接受造成阻塞，二是为了获取子进程中的文件描述符），然后父进程使用PTRACE_SYSCALL继续子进程；
   c. 使用wait等待这次调用（实际上是被替换来的recvmsg）的exit-stop，这时通过PTRACE_PEEKUSER从recvmsg的buf中获取子进程获得的文件描述符（记为fdc），然后通过PTRACE_SETREGS设置系统调用的返回值为fdc。

至此，父子进程中各有一个文件描述符（fdp和fdc），两者都指向同一个socket。

在这个过程中，还有一个值得一提的细节。由于recvmsg是在子进程中执行的，所以需要子进程提供一块可用的内存来完成这个调用。在目前的实现中，会在recvmsg执行之前，将当前栈顶所在的内存页面备份在父进程中，然后使用这个页面来执行recvmsg；该调用完成、并成功获取fdc后，再将栈顶所在页面还原。

3. 建立代理

在子进程调用connect之后，父进程查看参数，若需要进行代理，则通过connect中的文件描述符（fdc）查找对应的fdp，然后使用fdp向代理服务器发起连接和代理请求，代理建立完成后，父进程关闭fdp，并将当前的connect调用替换为一个无用的调用，比如sleep(0)，最后继续子进程。

## TODO

- [ ] 非阻塞IO

如果子进程对描述符使用了O_NONBLOCK，那么在connect时就没法直接通过fdp来建立代理。如果在connect之前将O_NONBLOCK去掉的话，子进程的非阻塞IO就可能明显变慢，尤其是连接非本地代理的时候。

问题在于，父进程没有合适的机会执行代理的连接了：子进程需要立即返回，在连接成功时通过多路复用取得信息；但父进程需要在此等待，以执行连接成功后的代理握手。

如果要更好地处理非阻塞IO，要么在父进程中使用accept，要么在处理一下epoll、select、poll等调用。用这两种方式可以在父进程中维护文件描述符的就绪状态。

本质上，父进程需要的是在连接真正成功之后进行代理握手，所以可以通过监控select调用，获得描述符的状态信息，在连接成功之后再进行代理握手。

像graftcp之所以不会遇到这个问题，是因为它在代理器中加了一层代理，代理器可以通过是否accept子进程的请求，来控制描述符的状态；从代理器的角度来讲，这种方式更为主动一些。

- [x] 过滤对描述符传送套接字的close

DONE

- [ ] 多线程和多进程

多线程和多进程情况下，有多个线程同时使用一个socketpair进行sendfd，同步问题不好处理。

多进程时，是否会出现sendfd到达的进程不确定的问题？

- [ ] fdp->fdc 哈希表

- [ ] exec时关闭不需要的文件

- [ ] 参数解析

- [ ] 支持 socks5/http 代理
